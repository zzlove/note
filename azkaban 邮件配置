默认azkaban.properties文件中关于邮件发送只有两行配置
```properties
mail.sender=
mail.host=
```
但是假如只配置了这两行，邮件是发送不出去的
```java
2019/01/23 18:58:36.911 +0800 ERROR [EmailMessage] [Azkaban] Connecting to SMTP server failed, attempt: 0
javax.mail.AuthenticationFailedException:
        at com.sun.mail.smtp.SMTPTransport$Authenticator.authenticate(SMTPTransport.java:823)
        at com.sun.mail.smtp.SMTPTransport.authenticate(SMTPTransport.java:756)
        at com.sun.mail.smtp.SMTPTransport.protocolConnect(SMTPTransport.java:673)
        at javax.mail.Service.connect(Service.java:295)
        at azkaban.utils.JavaxMailSender.connect(JavaxMailSender.java:34)
        at azkaban.utils.EmailMessage.connectToSMTPServer(EmailMessage.java:220)
        at azkaban.utils.EmailMessage.retryConnectToSMTPServer(EmailMessage.java:230)
        at azkaban.utils.EmailMessage.sendEmail(EmailMessage.java:213)
        at azkaban.utils.Emailer.sendEmail(Emailer.java:164)
        at azkaban.utils.Emailer.alertOnError(Emailer.java:137)
        at azkaban.executor.ExecutorManager.finalizeFlows(ExecutorManager.java:1281)
        at azkaban.executor.ExecutorManager.access$900(ExecutorManager.java:78)
```
首先确定端口是否是通的
```shell
telnet smtp.exmail.qq.com 25
```
输出Connected to smtp.exmail.qq.com.表示端口是通的
通过日志定位错误位置
```java
  private void connectToSMTPServer(final JavaxMailSender s) throws MessagingException {
    if (this._usesAuth) {
      s.connect(this._mailHost, this._mailPort, this._mailUser, this._mailPassword);
    } else {
      s.connect();
    }
  }

  private void retryConnectToSMTPServer(final JavaxMailSender s) throws MessagingException {
    int attempt;
    for (attempt = 0; attempt < MAX_EMAIL_RETRY_COUNT; attempt++) {
      try {
        connectToSMTPServer(s);
        return;
      } catch (final Exception e) {
        this.logger.error("Connecting to SMTP server failed, attempt: " + attempt, e);
      }
    }
    s.close();
    throw new MessagingException("Failed to connect to SMTP server after "
        + attempt + " attempts.");
  }
```
_usesAuth默认为true
```java
s.connect(this._mailHost, this._mailPort, this._mailUser, this._mailPassword);
```
需要4个参数，但是我们其实只配了1个。这4个值在EmailMessage的构造函数中被赋值
```java
  public EmailMessage(final String host, final int port, final String user, final String password,
      final EmailMessageCreator creator) {
    this._mailUser = user;
    this._mailHost = host;
    this._mailPort = port;
    this._mailPassword = password;
    this.creator = creator;
  }
```
再寻找EmailMessage什么时候初始化的,搜索new EmailMessage，定位到EmailMessageCreator类
```java
  public static final int DEFAULT_SMTP_PORT = 25;

  private final String mailHost;
  private final int mailPort;
  private final String mailUser;
  private final String mailPassword;
  private final String mailSender;
  private final String tls;
  private final boolean usesAuth;

  @Inject
  public EmailMessageCreator(final Props props) {
    this.mailHost = props.getString("mail.host", "localhost");
    this.mailPort = props.getInt("mail.port", DEFAULT_SMTP_PORT);
    this.mailUser = props.getString("mail.user", "");
    this.mailPassword = props.getString("mail.password", "");
    this.mailSender = props.getString("mail.sender", "");
    this.tls = props.getString("mail.tls", "false");
    this.usesAuth = props.getBoolean("mail.useAuth", true);
  }

  public EmailMessage createMessage() {
    final EmailMessage message = new EmailMessage(
        this.mailHost, this.mailPort, this.mailUser, this.mailPassword, this);
    message.setFromAddress(this.mailSender);
    message.setTLS(this.tls);
    message.setAuth(this.usesAuth);
    return message;
  }

  public JavaxMailSender createSender(final Properties props) throws NoSuchProviderException {
    return new JavaxMailSender(props);
  }
```
此时就很清楚了，EmailMessageCreator类初始化时从azkaban.proerties中读取mail配置，并给EmailMessage赋值。所以一共需要配置的参数包括
```java
    this.mailHost = props.getString("mail.host", "localhost");
    this.mailPort = props.getInt("mail.port", DEFAULT_SMTP_PORT);
    this.mailUser = props.getString("mail.user", "");
    this.mailPassword = props.getString("mail.password", "");
    this.mailSender = props.getString("mail.sender", "");
    this.tls = props.getString("mail.tls", "false");
    this.usesAuth = props.getBoolean("mail.useAuth", true);
```
azkaban-common工程下的util包的很多工具类我们可以直接拿来用的，最起码邮箱服务不用再自己手写了






